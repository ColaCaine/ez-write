<!doctype html>
<html>
<head>
<title>Ez-Draw</title>
</head>
<body>
<script>
    javascript:(function() {
    // --- Setup Canvas and Context ---
    var canvas = document.createElement('canvas');
    canvas.id = 'web-highlighter-canvas';
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.zIndex = '9999';
    canvas.style.pointerEvents = 'none';

    function updateCanvasSize() {
        var docWidth = Math.max(
            document.body.scrollWidth,
            document.documentElement.scrollWidth,
            document.body.offsetWidth,
            document.documentElement.offsetWidth,
            document.body.clientWidth,
            document.documentElement.clientWidth
        );
        var docHeight = Math.max(
            document.body.scrollHeight,
            document.documentElement.scrollHeight,
            document.body.offsetHeight,
            document.documentElement.offsetHeight,
            document.body.clientHeight,
            document.documentElement.clientHeight
        );
        canvas.width = docWidth;
        canvas.height = docHeight;
    }

    updateCanvasSize();
    document.body.appendChild(canvas);

    var ctx = canvas.getContext('2d');
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // --- State Variables ---
    var defaultLineWidth = 4;
    var currentLineWidth = defaultLineWidth;
    var currentColor = '#FF0000';
    var isErasing = false;
    var drawing = false;
    var drawingHistory = [];
    var currentSegment = null;
    var points = [];
    var lastPointerPos = { x: 0, y: 0 };

    // Undo/Redo Stacks
    var undoStack = [];
    var redoStack = [];

    var thicknessLevels = [2, 4, 8, 16, 24];

    // --- Custom Cursor ---
    var circleCursor = document.createElement('div');
    circleCursor.id = 'drawing-circle-cursor';
    circleCursor.style.position = 'fixed';
    circleCursor.style.pointerEvents = 'none';
    circleCursor.style.zIndex = '10001';
    circleCursor.style.width = currentLineWidth + 'px';
    circleCursor.style.height = currentLineWidth + 'px';
    circleCursor.style.border = '2px solid #444';
    circleCursor.style.borderRadius = '50%';
    circleCursor.style.transform = 'translate(-50%, -50%)';
    circleCursor.style.background = 'transparent';
    circleCursor.style.display = 'none';
    document.body.appendChild(circleCursor);

    function updateCursorSize() {
        var px = isErasing ? 20 : currentLineWidth;
        circleCursor.style.width = px + 'px';
        circleCursor.style.height = px + 'px';
        circleCursor.style.border = isErasing ? '2px dashed #f00' : '2px solid #444';
    }

    window.addEventListener('resize', updateCanvasSize);

    // --- Drawing Logic ---
    function drawSmoothedSegment(segment) {
        if (!segment.points || segment.points.length < 3) {
            if (segment.points && segment.points.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = segment.color || 'black';
                ctx.lineWidth = segment.isErasing ? 20 : (segment.thickness || defaultLineWidth);
                ctx.globalCompositeOperation = segment.isErasing ? 'destination-out' : 'source-over';
                ctx.moveTo(segment.points[0].x, segment.points[0].y);
                ctx.lineTo(segment.points[segment.points.length - 1].x, segment.points[segment.points.length - 1].y);
                ctx.stroke();
            }
            return;
        }

        ctx.strokeStyle = segment.color || 'black';
        ctx.lineWidth = segment.isErasing ? 20 : (segment.thickness || defaultLineWidth);
        ctx.globalCompositeOperation = segment.isErasing ? 'destination-out' : 'source-over';

        ctx.beginPath();
        ctx.moveTo(segment.points[0].x, segment.points[0].y);

        for (var i = 1; i < segment.points.length - 1; i++) {
            var p1 = segment.points[i];
            var p2 = segment.points[i + 1];
            var midPoint = {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        }
        ctx.lineTo(segment.points[segment.points.length - 1].x, segment.points[segment.points.length - 1].y);
        ctx.stroke();
    }

    function redraw() {
        updateCanvasSize();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawingHistory.forEach(drawSmoothedSegment);
        updateContextStyle();
    }

    function updateContextStyle() {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = isErasing ? 20 : currentLineWidth;
        ctx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
    }

    // --- Undo/Redo Functions ---
    function pushToUndo() {
        undoStack.push(JSON.stringify(drawingHistory));
        // Limit undoStack to 100 for memory
        if (undoStack.length > 100) undoStack.shift();
    }
    function undo() {
        if (undoStack.length === 0) return;
        redoStack.push(JSON.stringify(drawingHistory));
        drawingHistory = JSON.parse(undoStack.pop());
        redraw();
    }
    function redo() {
        if (redoStack.length === 0) return;
        undoStack.push(JSON.stringify(drawingHistory));
        drawingHistory = JSON.parse(redoStack.pop());
        redraw();
    }

    // --- Mouse/Pen Event Handlers ---
    function getPointerPos(e) {
        var x = (e.touches ? e.touches[0].clientX : e.clientX) + window.scrollX;
        var y = (e.touches ? e.touches[0].clientY : e.clientY) + window.scrollY;
        return { x, y };
    }

    document.addEventListener('mousemove', function(e) {
        lastPointerPos = { x: e.clientX, y: e.clientY };
        circleCursor.style.display =
            e.target === canvas || !toolContainer.contains(e.target) ? 'block' : 'none';
        circleCursor.style.left = e.clientX + 'px';
        circleCursor.style.top = e.clientY + 'px';
    });

    document.addEventListener('mousedown', function(e) {
        if (toolContainer.contains(e.target) || e.button !== 0) return;
        drawing = true;
        points = [];

        // Save history for undo before every new segment
        pushToUndo();
        redoStack = [];

        currentSegment = {
            color: currentColor,
            isErasing: isErasing,
            thickness: currentLineWidth,
            points: []
        };
        drawingHistory.push(currentSegment);

        updateContextStyle();

        var pos = getPointerPos(e);
        points.push({ x: pos.x, y: pos.y });
        currentSegment.points.push({ x: pos.x, y: pos.y });

        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);

        circleCursor.style.display = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', function(e) {
        if (!drawing) return;
        var pos = getPointerPos(e);
        points.push({ x: pos.x, y: pos.y });
        currentSegment.points.push({ x: pos.x, y: pos.y });
        if (points.length > 2) {
            redraw();
        } else {
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
        e.preventDefault();
    });

    document.addEventListener('mouseup', function(e) {
        if (!drawing) return;
        drawing = false;
        points = [];
        redraw();
        circleCursor.style.display = 'block';
        e.preventDefault();
    });

    document.addEventListener('mouseout', function(e) {
        if (!drawing) return;
        drawing = false;
        points = [];
        redraw();
        circleCursor.style.display = 'block';
    });

    // Touch support
    document.addEventListener('touchstart', function(e) {
        if (toolContainer.contains(e.target)) return;
        drawing = true;
        points = [];
        // Save history for undo before every new segment
        pushToUndo();
        redoStack = [];
        var pos = getPointerPos(e);

        currentSegment = {
            color: currentColor,
            isErasing: isErasing,
            thickness: currentLineWidth,
            points: []
        };
        drawingHistory.push(currentSegment);

        updateContextStyle();
        points.push({ x: pos.x, y: pos.y });
        currentSegment.points.push({ x: pos.x, y: pos.y });

        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);

        circleCursor.style.display = 'none';
        e.preventDefault();
    }, {passive: false});

    document.addEventListener('touchmove', function(e) {
        if (!drawing) return;
        var pos = getPointerPos(e);
        points.push({ x: pos.x, y: pos.y });
        currentSegment.points.push({ x: pos.x, y: pos.y });

        if (points.length > 2) {
            redraw();
        } else {
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
        e.preventDefault();
    }, {passive: false});

    document.addEventListener('touchend', function(e) {
        if (!drawing) return;
        drawing = false;
        points = [];
        redraw();
        circleCursor.style.display = 'block';
        e.preventDefault();
    }, {passive: false});

    // --- Keyboard Undo/Redo Shortcuts ---
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'z') {
            e.preventDefault();
            undo();
        } else if ((e.ctrlKey && e.key.toLowerCase() === 'y') || (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z')) {
            e.preventDefault();
            redo();
        }
    });

    // --- Utility and UI Functions ---
    function downloadFile(data, filename, type) {
        var file = new Blob([data], { type: type });
        var a = document.createElement('a');
        a.href = URL.createObjectURL(file);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    function clearDrawing() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawingHistory = [];
        undoStack = [];
        redoStack = [];
    }
    function exportJSON() {
        var jsonState = JSON.stringify({
            url: window.location.href,
            timestamp: new Date().toISOString(),
            width: canvas.width,
            height: canvas.height,
            history: drawingHistory
        });
        downloadFile(jsonState, 'web-drawing-state.json', 'application/json');
    }
    function importJSON() {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.style.display = 'none';
        input.onchange = function(e) {
            var file = e.target.files[0];
            if (!file) return;
            var reader = new FileReader();
            reader.onload = function(event) {
                try {
                    var data = JSON.parse(event.target.result);
                    if (data && data.history) {
                        pushToUndo();
                        drawingHistory = data.history;
                        redoStack = [];
                        redraw();
                        alert('Drawing imported successfully!');
                    } else {
                        throw new Error('Invalid JSON structure.');
                    }
                } catch (error) {
                    alert('Error importing drawing: ' + error.message);
                }
                document.body.removeChild(input);
            };
            reader.readAsText(file);
        };
        document.body.appendChild(input);
        input.click();
    }
    function exportJPEG() {
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        var tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.drawImage(canvas, 0, 0);

        try {
            var imageDataURL = tempCanvas.toDataURL('image/jpeg', 0.9);
            var link = document.createElement('a');
            link.href = imageDataURL;
            link.download = 'web-drawing-screenshot.jpeg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            alert('Export failed. Note: Exporting to JPEG may fail on cross-origin content.');
        }
    }
    function removeTools() {
        if (document.getElementById('web-highlighter-canvas')) {
            document.body.removeChild(canvas);
        }
        if (document.getElementById('tool-container')) {
            document.body.removeChild(toolContainer);
        }
        if (document.getElementById('drawing-circle-cursor')) {
            document.body.removeChild(circleCursor);
        }
    }
    function setThickness(thickness) {
        currentLineWidth = thickness;
        isErasing = false;
        eraserButton.textContent = 'Eraser Mode';
        eraserButton.style.backgroundColor = '#eee';
        colorPicker.style.display = 'inline-block';
        updateContextStyle();
        updateCursorSize();
        document.querySelectorAll('#thickness-buttons button').forEach(btn => {
            btn.style.border = '1px solid #aaa';
        });
        document.getElementById('thickness-btn-' + thickness).style.border = '2px solid blue';
    }
    function toggleEraser() {
        isErasing = !isErasing;
        if (isErasing) {
            eraserButton.textContent = 'Draw Mode (' + currentLineWidth + 'px)';
            eraserButton.style.backgroundColor = '#f00';
            colorPicker.style.display = 'none';
        } else {
            eraserButton.textContent = 'Eraser Mode';
            eraserButton.style.backgroundColor = '#eee';
            colorPicker.style.display = 'inline-block';
        }
        updateContextStyle();
        updateCursorSize();
    }

    // --- Create and Style UI Elements ---
    var toolContainer = document.createElement('div');
    toolContainer.id = 'tool-container';
    toolContainer.style.position = 'fixed';
    toolContainer.style.top = '10px';
    toolContainer.style.right = '10px';
    toolContainer.style.zIndex = '10003';
    toolContainer.style.padding = '10px';
    toolContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    toolContainer.style.border = '1px solid #ccc';
    toolContainer.style.borderRadius = '5px';
    toolContainer.style.display = 'flex';
    toolContainer.style.gap = '5px';
    toolContainer.style.flexDirection = 'column';

    function createButton(text, onClick) {
        var btn = document.createElement('button');
        btn.textContent = text;
        btn.onclick = onClick;
        btn.style.padding = '5px 10px';
        btn.style.border = '1px solid #aaa';
        btn.style.borderRadius = '3px';
        btn.style.cursor = 'pointer';
        return btn;
    }

    // Color Picker
    var colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = currentColor;
    colorPicker.onchange = function() {
        currentColor = colorPicker.value;
        isErasing = false;
        eraserButton.textContent = 'Eraser Mode';
        eraserButton.style.backgroundColor = '#eee';
        updateContextStyle();
        updateCursorSize();
    };

    // Thickness Buttons Container
    var thicknessContainer = document.createElement('div');
    thicknessContainer.id = 'thickness-buttons';
    thicknessContainer.style.display = 'flex';
    thicknessContainer.style.gap = '2px';
    thicknessContainer.style.marginBottom = '5px';

    thicknessLevels.forEach(thickness => {
        var btn = document.createElement('button');
        btn.id = 'thickness-btn-' + thickness;
        btn.textContent = thickness + 'px';
        btn.style.width = '35px';
        btn.style.height = '25px';
        btn.style.padding = '0';
        btn.style.fontSize = '10px';
        btn.style.cursor = 'pointer';
        btn.onclick = function() {
            setThickness(thickness);
        };
        thicknessContainer.appendChild(btn);
    });

    // Undo/Redo Buttons
    var undoBtn = createButton('Undo (Ctrl+Z)', undo);
    var redoBtn = createButton('Redo (Ctrl+Y/Ctrl+Shift+Z)', redo);

    toolContainer.appendChild(thicknessContainer);
    toolContainer.appendChild(colorPicker);
    toolContainer.appendChild(undoBtn);
    toolContainer.appendChild(redoBtn);

    var eraserButton = createButton('Eraser Mode', toggleEraser);
    toolContainer.appendChild(eraserButton);

    toolContainer.appendChild(createButton('Clear Drawing', clearDrawing));
    toolContainer.appendChild(createButton('Export as JSON', exportJSON));
    toolContainer.appendChild(createButton('Import from JSON', importJSON));
    toolContainer.appendChild(createButton('Export as JPEG (White BG)', exportJPEG));
    toolContainer.appendChild(createButton('Remove Tools', removeTools));

    document.body.appendChild(toolContainer);

    setThickness(defaultLineWidth);
    updateCursorSize();

    window.addEventListener('scroll', function() {
        circleCursor.style.left = lastPointerPos.x + 'px';
        circleCursor.style.top = lastPointerPos.y + 'px';
    });

    document.addEventListener('mousemove', function(e) {
        if (toolContainer.contains(e.target)) {
            canvas.style.cursor = 'default';
        } else {
            canvas.style.cursor = 'none';
        }
    });
})();
</script>
</body>
</html>
