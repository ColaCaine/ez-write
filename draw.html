<!doctype html>
<html>
<head>
<link rel="icon" href="ez.png" type="image/x-icon">
<title>Ez-Draw</title>
</head>
<body>
<script>
javascript:(function () {
    // --- Virtual canvas settings ---
    var VIRTUAL_SIZE = 100000;
    var VIRTUAL_HALF = VIRTUAL_SIZE / 2;
    var MIN_ZOOM = 0.05, MAX_ZOOM = 5;

    // --- State ---
    var zoom = 1.0;
    var offsetX = VIRTUAL_HALF, offsetY = VIRTUAL_HALF; // Pan so that view is centered at start
    var isPanning = false, panLast = { x: 0, y: 0 };
    var drawing = false, isErasing = false;
    var currentLineWidth = 4, currentColor = "#FF0000";
    var thicknessLevels = [2, 4, 8, 16, 24];
    var assistLevel = 2, assistLabels = ["None", "Low", "Medium", "High"];
    var drawingHistory = [], undoStack = [], redoStack = [];
    var currentSegment = null, points = [];
    var lastPointerPos = { x:0, y:0 };

    // --- DOM setup ---
    var canvas = document.createElement("canvas");
    canvas.style.position = "fixed";
    canvas.style.left = "0"; canvas.style.top = "0";
    canvas.style.zIndex = "9999";
    canvas.style.pointerEvents = "none";
    // Enable high-DPI/retina anti-aliasing
    var dpr = window.devicePixelRatio || 1;
    document.body.appendChild(canvas);
    var ctx = canvas.getContext("2d");

    function resize() {
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
        cacheCanvas.width = window.innerWidth * dpr;
        cacheCanvas.height = window.innerHeight * dpr;
        cacheCanvas.style.width = window.innerWidth + "px";
        cacheCanvas.style.height = window.innerHeight + "px";
        cacheDirty = true;
        scheduleRedraw();
    }
    window.addEventListener("resize", resize);

    // --- Performance cache ---
    var cacheCanvas = document.createElement("canvas"), cacheCtx = cacheCanvas.getContext("2d");
    cacheCanvas.width = window.innerWidth * dpr; cacheCanvas.height = window.innerHeight * dpr;
    var cacheDirty = true;

    // --- UI ---
    var toolContainer = document.createElement('div');
    toolContainer.id = 'tool-container';
    toolContainer.style.position = 'fixed';
    toolContainer.style.top = '10px';
    toolContainer.style.right = '10px';
    toolContainer.style.zIndex = '10003';
    toolContainer.style.padding = '10px';
    toolContainer.style.backgroundColor = 'rgba(255,255,255,0.9)';
    toolContainer.style.border = '1px solid #ccc';
    toolContainer.style.borderRadius = '5px';
    toolContainer.style.display = 'flex';
    toolContainer.style.gap = '5px';
    toolContainer.style.flexDirection = 'column';
    document.body.appendChild(toolContainer);

    function createButton(text, onClick) {
        var btn = document.createElement('button');
        btn.textContent = text;
        btn.onclick = onClick;
        btn.style.padding = '5px 10px';
        btn.style.border = '1px solid #aaa';
        btn.style.borderRadius = '3px';
        btn.style.cursor = 'pointer';
        return btn;
    }

    // Smoothing/Aim Assist Select
    var assistSelect = document.createElement('select');
    assistSelect.title = "Drawing Smoothing/Aim Assist";
    assistLabels.forEach((label, idx) => {
        var opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = "Assist: " + label;
        assistSelect.appendChild(opt);
    });
    assistSelect.value = assistLevel;
    assistSelect.onchange = function() {
        assistLevel = parseInt(this.value, 10);
    };
    assistSelect.style.marginBottom = '6px';
    assistSelect.style.fontSize = '13px';

    // Color Picker
    var colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = currentColor;
    colorPicker.onchange = function() {
        currentColor = colorPicker.value;
        isErasing = false;
        eraserButton.textContent = 'Eraser Mode';
        eraserButton.style.backgroundColor = '#eee';
        updateContextStyle();
        updateCursorSize();
        cacheDirty = true; scheduleRedraw();
    };

    // Thickness Buttons
    var thicknessContainer = document.createElement('div');
    thicknessContainer.id = 'thickness-buttons';
    thicknessContainer.style.display = 'flex';
    thicknessContainer.style.gap = '2px';
    thicknessContainer.style.marginBottom = '5px';
    thicknessLevels.forEach(thickness => {
        var btn = document.createElement('button');
        btn.id = 'thickness-btn-' + thickness;
        btn.textContent = thickness + 'px';
        btn.style.width = '35px';
        btn.style.height = '25px';
        btn.style.padding = '0';
        btn.style.fontSize = '10px';
        btn.style.cursor = 'pointer';
        btn.onclick = function() { setThickness(thickness); };
        thicknessContainer.appendChild(btn);
    });

    var undoBtn = createButton('Undo (Ctrl+Z)', undo);
    var redoBtn = createButton('Redo (Ctrl+Y/Ctrl+Shift+Z)', redo);

    // --- Add "Go to Origin" Button ---
    function goToOrigin() {
        // Center on the virtual canvas and reset zoom
        zoom = 1.0;
        offsetX = VIRTUAL_HALF;
        offsetY = VIRTUAL_HALF;
        cacheDirty = true;
        scheduleRedraw();
    }
    var originBtn = createButton('Go to Origin', goToOrigin);

    var eraserButton = createButton('Eraser Mode', toggleEraser);

    toolContainer.appendChild(assistSelect);
    toolContainer.appendChild(thicknessContainer);
    toolContainer.appendChild(colorPicker);
    toolContainer.appendChild(undoBtn);
    toolContainer.appendChild(redoBtn);
    toolContainer.appendChild(originBtn);
    toolContainer.appendChild(eraserButton);
    toolContainer.appendChild(createButton('Clear Drawing', clearDrawing));
    toolContainer.appendChild(createButton('Export as JSON', exportJSON));
    toolContainer.appendChild(createButton('Import from JSON', importJSON));
    toolContainer.appendChild(createButton('Export as JPEG (White BG)', exportJPEG));

    // --- Custom Cursor ---
    var circleCursor = document.createElement('div');
    circleCursor.id = 'drawing-circle-cursor';
    circleCursor.style.position = 'fixed';
    circleCursor.style.pointerEvents = 'none';
    circleCursor.style.zIndex = '10001';
    circleCursor.style.width = currentLineWidth + 'px';
    circleCursor.style.height = currentLineWidth + 'px';
    circleCursor.style.border = '2px solid #444';
    circleCursor.style.borderRadius = '50%';
    circleCursor.style.transform = 'translate(-50%, -50%)';
    circleCursor.style.background = 'transparent';
    circleCursor.style.display = 'none';
    document.body.appendChild(circleCursor);

    function updateCursorSize() {
        var px = isErasing ? 20 : currentLineWidth;
        circleCursor.style.width = px + 'px';
        circleCursor.style.height = px + 'px';
        circleCursor.style.border = isErasing ? '2px dashed #f00' : '2px solid #444';
    }

    function setThickness(thickness) {
        currentLineWidth = thickness;
        isErasing = false;
        eraserButton.textContent = 'Eraser Mode';
        eraserButton.style.backgroundColor = '#eee';
        colorPicker.style.display = 'inline-block';
        updateContextStyle();
        updateCursorSize();
        document.querySelectorAll('#thickness-buttons button').forEach(btn => {
            btn.style.border = '1px solid #aaa';
        });
        document.getElementById('thickness-btn-' + thickness).style.border = '2px solid blue';
        cacheDirty = true; scheduleRedraw();
    }
    function toggleEraser() {
        isErasing = !isErasing;
        if (isErasing) {
            eraserButton.textContent = 'Draw Mode (' + currentLineWidth + 'px)';
            eraserButton.style.backgroundColor = '#f00';
            colorPicker.style.display = 'none';
        } else {
            eraserButton.textContent = 'Eraser Mode';
            eraserButton.style.backgroundColor = '#eee';
            colorPicker.style.display = 'inline-block';
        }
        updateContextStyle();
        updateCursorSize();
        cacheDirty = true; scheduleRedraw();
    }

    // --- Drawing logic ---
    function smoothPoints(points, level) {
        if (level === 0 || points.length < 3) return points.slice();
        const settings = [
            {window: 0, strength: 0},
            {window: 2, strength: 0.4},
            {window: 4, strength: 0.7},
            {window: 8, strength: 0.85},
        ][level];
        const w = settings.window, s = settings.strength;
        let out = [];
        for (let i = 0; i < points.length; i++) {
            let sx = 0, sy = 0, count = 0;
            for (let j = -w; j <= w; j++) {
                let idx = Math.max(0, Math.min(points.length - 1, i + j));
                sx += points[idx].x;
                sy += points[idx].y;
                count++;
            }
            let avgx = sx / count, avgy = sy / count;
            out.push({
                x: points[i].x * (1 - s) + avgx * s,
                y: points[i].y * (1 - s) + avgy * s
            });
        }
        return out;
    }

    function lerp(a,b,t){ return a+(b-a)*t; }

function drawSmoothLineSegment(context, segment, scrollX, scrollY) {
    let pts = smoothPoints(segment.points, segment.assistLevel ?? assistLevel);
    if (!pts.length) return;
    context.save();
    context.globalCompositeOperation = segment.isErasing ? 'destination-out' : 'source-over';
    context.strokeStyle = segment.color || 'black';
    context.lineWidth = segment.isErasing ? 20 : (segment.thickness || currentLineWidth);
    context.lineCap = "round";
    context.lineJoin = "round";
    context.beginPath();
    context.moveTo((pts[0].x - scrollX) * dpr, (pts[0].y - scrollY) * dpr);
    if (pts.length == 1) {
        // Draw a dot
        context.arc((pts[0].x - scrollX) * dpr, (pts[0].y - scrollY) * dpr, context.lineWidth / 2 * dpr, 0, 2 * Math.PI);
        context.fill();
    } else if (pts.length == 2) {
        context.lineTo((pts[1].x - scrollX) * dpr, (pts[1].y - scrollY) * dpr);
        context.stroke();
    } else {
        for (let i = 1; i < pts.length - 2; i++) {
            let xc = ((pts[i].x + pts[i + 1].x) / 2 - scrollX) * dpr;
            let yc = ((pts[i].y + pts[i + 1].y) / 2 - scrollY) * dpr;
            context.quadraticCurveTo(
                (pts[i].x - scrollX) * dpr,
                (pts[i].y - scrollY) * dpr,
                xc,
                yc
            );
        }
        // Final curve
        let n = pts.length - 1;
        context.quadraticCurveTo(
            (pts[n - 1].x - scrollX) * dpr,
            (pts[n - 1].y - scrollY) * dpr,
            (pts[n].x - scrollX) * dpr,
            (pts[n].y - scrollY) * dpr
        );
        context.stroke();
    }
    context.restore();
}
    function updateCacheCanvas() {
        cacheCanvas.width = window.innerWidth * dpr;
        cacheCanvas.height = window.innerHeight * dpr;
        cacheCtx.clearRect(0, 0, cacheCanvas.width, cacheCanvas.height);
        var sx = offsetX - window.innerWidth/2/zoom,
            sy = offsetY - window.innerHeight/2/zoom;
        for (var i = 0; i < drawingHistory.length - (drawing ? 1 : 0); i++) {
            var seg = drawingHistory[i];
            cacheCtx.save();
            cacheCtx.globalCompositeOperation = seg.isErasing ? 'destination-out' : 'source-over';
            cacheCtx.setTransform(zoom * dpr,0,0,zoom * dpr,-sx*zoom*dpr,-sy*zoom*dpr);
            drawSmoothLineSegment(cacheCtx, seg, 0, 0);
            cacheCtx.setTransform(1,0,0,1,0,0);
            cacheCtx.restore();
        }
        cacheDirty = false;
    }

    var redrawScheduled = false;
    function scheduleRedraw() { if(!redrawScheduled){ redrawScheduled=true; requestAnimationFrame(redraw); } }
    function redraw() {
        redrawScheduled = false;
        if (cacheDirty) updateCacheCanvas();
        ctx.globalCompositeOperation = 'source-over';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 1. Draw normal lines
        ctx.drawImage(cacheCanvas, 0, 0);

        // 2. Overlay blurred version for soft edge anti-aliasing
        ctx.save();
        ctx.globalAlpha = 0.33;
        ctx.filter = 'blur(1.2px)';
        ctx.drawImage(cacheCanvas, 0, 0);
        ctx.filter = 'none';
        ctx.globalAlpha = 1;
        ctx.restore();

        // In-progress stroke
        if (drawing && drawingHistory.length) {
            ctx.save();
            var sx = offsetX - window.innerWidth/2/zoom,
                sy = offsetY - window.innerHeight/2/zoom;
            ctx.setTransform(zoom*dpr,0,0,zoom*dpr,-sx*zoom*dpr,-sy*zoom*dpr);
            ctx.globalCompositeOperation = drawingHistory[drawingHistory.length-1].isErasing ? 'destination-out' : 'source-over';
            drawSmoothLineSegment(ctx, drawingHistory[drawingHistory.length-1], 0, 0);
            ctx.setTransform(1,0,0,1,0,0);
            ctx.restore();
        }
        updateContextStyle();
    }

    function updateContextStyle() {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = isErasing ? 20 : currentLineWidth;
    }

    // --- Undo/Redo Functions ---
    function pushToUndo() {
        undoStack.push(JSON.stringify(drawingHistory));
        if (undoStack.length > 100) undoStack.shift();
    }
    function undo() {
        if (undoStack.length === 0) return;
        redoStack.push(JSON.stringify(drawingHistory));
        drawingHistory = JSON.parse(undoStack.pop());
        cacheDirty = true;
        scheduleRedraw();
    }
    function redo() {
        if (redoStack.length === 0) return;
        undoStack.push(JSON.stringify(drawingHistory));
        drawingHistory = JSON.parse(redoStack.pop());
        cacheDirty = true;
        scheduleRedraw();
    }

    // --- Drawing and Pan/Zoom Events ---
    function getVirtualPointer(e) {
        var px = (e.touches ? e.touches[0].clientX : e.clientX),
            py = (e.touches ? e.touches[0].clientY : e.clientY);
        var vpx = (px / zoom) + (offsetX - window.innerWidth/2/zoom),
            vpy = (py / zoom) + (offsetY - window.innerHeight/2/zoom);
        return { x: vpx, y: vpy, screenX: px, screenY: py };
    }

    function isPanEvent(e) {
        return (e.button === 2) || (e.shiftKey && e.button === 0);
    }

    canvas.oncontextmenu = function(e) { e.preventDefault(); return false; };

    document.addEventListener('mousedown', function(e) {
        if (toolContainer.contains(e.target)) return;
        if (isPanEvent(e)) {
            isPanning = true;
            panLast = { x: e.clientX, y: e.clientY };
        } else if (e.button === 0) {
            drawing = true;
            points = [];
            pushToUndo();
            redoStack = [];
            currentSegment = {
                color: currentColor,
                isErasing: isErasing,
                thickness: currentLineWidth,
                points: [],
                assistLevel: assistLevel
            };
            drawingHistory.push(currentSegment);
            updateContextStyle();
            var pos = getVirtualPointer(e);
            points.push({ x: pos.x, y: pos.y });
            currentSegment.points.push({ x: pos.x, y: pos.y });
            scheduleRedraw();
            circleCursor.style.display = 'none';
        }
        e.preventDefault();
    });

    document.addEventListener('mousemove', function(e) {
        lastPointerPos = { x: e.clientX, y: e.clientY };
        circleCursor.style.display =
            e.target === canvas || !toolContainer.contains(e.target) ? 'block' : 'none';
        circleCursor.style.left = e.clientX + 'px';
        circleCursor.style.top = e.clientY + 'px';

        if (isPanning) {
            var dx = (e.clientX - panLast.x) / zoom,
                dy = (e.clientY - panLast.y) / zoom;
            offsetX -= dx;
            offsetY -= dy;
            panLast = { x: e.clientX, y: e.clientY };
            cacheDirty = true; scheduleRedraw();
        } else if (drawing) {
            var pos = getVirtualPointer(e);
            points.push({ x: pos.x, y: pos.y });
            currentSegment.points.push({ x: pos.x, y: pos.y });
            scheduleRedraw();
        }
    });

    document.addEventListener('mouseup', function(e) {
        if (isPanning) {
            isPanning = false;
        }
        if (drawing) {
            drawing = false;
            points = [];
            cacheDirty = true;
            scheduleRedraw();
            circleCursor.style.display = 'block';
        }
        e.preventDefault();
    });

    document.addEventListener('mouseout', function(e) {
        if (isPanning || drawing) {
            isPanning = false;
            drawing = false;
            points = [];
            cacheDirty = true;
            scheduleRedraw();
            circleCursor.style.display = 'block';
        }
    });

    // --- Touch support for draw/pan ---
    document.addEventListener('touchstart', function(e) {
        if (toolContainer.contains(e.target)) return;
        if (e.touches.length === 2) {
            isPanning = true;
            panLast = {
                x: (e.touches[0].clientX + e.touches[1].clientX)/2,
                y: (e.touches[0].clientY + e.touches[1].clientY)/2
            };
        } else {
            drawing = true;
            points = [];
            pushToUndo();
            redoStack = [];
            var pos = getVirtualPointer(e);
            currentSegment = {
                color: currentColor,
                isErasing: isErasing,
                thickness: currentLineWidth,
                points: [],
                assistLevel: assistLevel
            };
            drawingHistory.push(currentSegment);
            updateContextStyle();
            points.push({ x: pos.x, y: pos.y });
            currentSegment.points.push({ x: pos.x, y: pos.y });
            scheduleRedraw();
            circleCursor.style.display = 'none';
        }
        e.preventDefault();
    }, {passive: false});
    document.addEventListener('touchmove', function(e) {
        if (isPanning && e.touches.length === 2) {
            var nx = (e.touches[0].clientX + e.touches[1].clientX)/2,
                ny = (e.touches[0].clientY + e.touches[1].clientY)/2;
            var dx = (nx - panLast.x) / zoom,
                dy = (ny - panLast.y) / zoom;
            offsetX -= dx;
            offsetY -= dy;
            panLast = { x: nx, y: ny };
            cacheDirty = true; scheduleRedraw();
        } else if (drawing) {
            var pos = getVirtualPointer(e);
            points.push({ x: pos.x, y: pos.y });
            currentSegment.points.push({ x: pos.x, y: pos.y });
            scheduleRedraw();
        }
        e.preventDefault();
    }, {passive: false});
    document.addEventListener('touchend', function(e) {
        if (isPanning && e.touches.length < 2) isPanning = false;
        if (drawing && e.touches.length === 0) {
            drawing = false;
            points = [];
            cacheDirty = true;
            scheduleRedraw();
            circleCursor.style.display = 'block';
        }
        e.preventDefault();
    }, {passive: false});

    // --- Mouse wheel: zoom ---
    window.addEventListener('wheel', function(e) {
        if (toolContainer.contains(e.target)) return;
        var mx = e.clientX, my = e.clientY;
        var wx = (mx / zoom) + (offsetX - window.innerWidth/2/zoom),
            wy = (my / zoom) + (offsetY - window.innerHeight/2/zoom);
        var delta = -e.deltaY * (e.deltaMode === 1 ? 0.01 : 0.002); // Normalize wheel delta
        var newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom * (1 + delta)));
        // Keep the zoom centered on mouse
        offsetX = wx - (mx / newZoom) + window.innerWidth/2/newZoom;
        offsetY = wy - (my / newZoom) + window.innerHeight/2/newZoom;
        zoom = newZoom;
        cacheDirty = true;
        scheduleRedraw();
        e.preventDefault();
    }, {passive:false});

    // --- Undo/Redo Shortcuts ---
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'z') {
            e.preventDefault(); undo();
        } else if ((e.ctrlKey && e.key.toLowerCase() === 'y') || (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z')) {
            e.preventDefault(); redo();
        }
    });

    // --- Utility and UI Functions ---
    function downloadFile(data, filename, type) {
        var file = new Blob([data], { type: type });
        var a = document.createElement('a');
        a.href = URL.createObjectURL(file);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    function clearDrawing() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawingHistory = [];
        undoStack = [];
        redoStack = [];
        cacheDirty = true;
        scheduleRedraw();
    }
    function exportJSON() {
        var jsonState = JSON.stringify({
            url: window.location.href,
            timestamp: new Date().toISOString(),
            history: drawingHistory
        });
        downloadFile(jsonState, 'web-drawing-state.json', 'application/json');
    }
    function importJSON() {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.style.display = 'none';
        input.onchange = function(e) {
            var file = e.target.files[0];
            if (!file) return;
            var reader = new FileReader();
            reader.onload = function(event) {
                try {
                    var data = JSON.parse(event.target.result);
                    if (data && data.history) {
                        pushToUndo();
                        drawingHistory = data.history;
                        redoStack = [];
                        cacheDirty = true;
                        scheduleRedraw();
                        alert('Drawing imported successfully!');
                    } else {
                        throw new Error('Invalid JSON structure.');
                    }
                } catch (error) {
                    alert('Error importing drawing: ' + error.message);
                }
                document.body.removeChild(input);
            };
            reader.readAsText(file);
        };
        document.body.appendChild(input);
        input.click();
    }
    function exportJPEG() {
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = window.innerWidth * dpr;
        tempCanvas.height = window.innerHeight * dpr;
        var tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, tempCanvas.width, tempCanvas.height);
        try {
            var imageDataURL = tempCanvas.toDataURL('image/jpeg', 0.9);
            var link = document.createElement('a');
            link.href = imageDataURL;
            link.download = 'web-drawing-screenshot.jpeg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            alert('Export failed. Note: Exporting to JPEG may fail on cross-origin content.');
        }
    }

    setThickness(4); // default
    updateCursorSize(); // default
    resize();
    // Center on virtual canvas
    offsetX = VIRTUAL_HALF;
    offsetY = VIRTUAL_HALF;
    cacheDirty = true;
    scheduleRedraw();

    // Always keep canvas on top and correct size
    window.addEventListener('scroll', function() {
        cacheDirty = true; scheduleRedraw();
        circleCursor.style.left = lastPointerPos.x + 'px';
        circleCursor.style.top = lastPointerPos.y + 'px';
    });

    document.addEventListener('mousemove', function(e) {
        if (toolContainer.contains(e.target)) {
            canvas.style.cursor = 'default';
        } else {
            canvas.style.cursor = 'none';
        }
    });
})();
</script>
</body>
</html>
